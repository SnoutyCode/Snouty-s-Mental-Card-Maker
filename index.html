<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Carte mentale interactive</title>
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="https://cdn-icons-png.flaticon.com/512/5230/5230593.png"
    />
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }

      path {
        fill: none;
        stroke: #555;
        stroke-width: 2px;
      }

      circle {
        fill: #b3e5ff;
        stroke: #333;
        stroke-width: 2px;
        cursor: pointer;
      }

      circle.selected {
        fill: #33b5ec !important;
        stroke: black !important;
        stroke-width: 2px !important;
      }

      rect {
        fill: #b3e5ff;
        stroke: #333;
        stroke-width: 2px;
        cursor: pointer;
        rx: 8;
      }

      rect.selected {
        fill: #33b5ec !important;
        stroke: black !important;
        stroke-width: 2px !important;
      }

      text {
        font-size: 13px;
        pointer-events: none;
        fill: #000;
      }

      #toolbar {
        position: fixed;
        top: 10px;
        left: 10px;
        background: white;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        z-index: 10;
      }

      button {
        margin: 2px;
      }
    </style>
  </head>

  <body>
    <div id="toolbar">
      <button onclick="addChild()">‚ûï Ajouter une bulle (A)</button>
      <button onclick="renameNode()">‚úèÔ∏è Renommer (Enter)</button>
      <button onclick="deleteNode()">‚ùå Supprimer (Delete)</button>
      <button onclick="changeColor()">üé® Changer de couleur</button>
      <button onclick="renameMap()">üìù Renommer la carte (R)</button>
      <button onclick="exportData()">üì• Exporter (F7)</button>
      <button onclick="importData()">üì§ Importer (I)</button>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none" />
    <input type="color" id="colorPicker" style="display: none" />

    <svg></svg>

    <script>
      // =======================
      // Donn√©es
      // =======================
      let data = {
        name: "Ma Carte Mentale",
      };

      // =======================
      // SVG & Zoom
      // =======================
      const width = window.innerWidth;
      const height = window.innerHeight;

      const svg = d3.select("svg").attr("width", width).attr("height", height);

      const g = svg
        .append("g")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);

      svg.call(
        d3
          .zoom()
          .scaleExtent([0.3, 3])
          .on("zoom", (event) => g.attr("transform", event.transform)),
      );

      // =======================
      // S√©lection
      // =======================
      let selectedNodeData = null;

      function isSelectedNode(d) {
        return selectedNodeData === d.data;
      }

      // =======================
      // Drag des n≈ìuds
      // =======================
      const drag = d3
        .drag()
        .on("start", (event, d) => {
          event.sourceEvent.stopPropagation();
          // Initialiser la position si elle n'existe pas
          if (d.data.x_manual === undefined) {
            const pos = polarToCartesian(d.x, d.y);
            d.data.x_manual = pos.x;
            d.data.y_manual = pos.y;
          }
        })
        .on("drag", (event, d) => {
          // Utiliser les mouvements incr√©mentaux pour accumuler la position
          d.data.x_manual += event.dx;
          d.data.y_manual += event.dy;
          update();
        });

      // =======================
      // Utilitaires
      // =======================

      function polarToCartesian(angle, radius) {
        return {
          x: Math.cos(angle - Math.PI / 2) * radius,
          y: Math.sin(angle - Math.PI / 2) * radius,
        };
      }

      function getNodeRadius(d) {
        const textLength = d.data.name.length;
        const minRadius = d.depth === 0 ? 35 : 20;
        const maxRadius = 80; // Limite maximale du rayon

        // Estimation : largeur moyenne d'un caract√®re ‚âà 7px avec police 13px
        // Ajouter du padding (10px)
        const estimatedWidth = textLength * 7 + 10;
        const requiredRadius = estimatedWidth / 2;

        return Math.min(maxRadius, Math.max(minRadius, requiredRadius));
      }

      function shouldUseRectangle(d) {
        // Utiliser un rectangle si le texte fait plus de 20 caract√®res
        return d.data.name.length > 20;
      }

      function getNodeDimensions(d) {
        const padding = 12;
        const charWidth = 8.5; // Estimation plus pr√©cise avec police 13px
        const lineHeight = 18;

        if (shouldUseRectangle(d)) {
          // Pour un rectangle, on enveloppe le texte avec ajustement dynamique
          let maxCharsPerLine = 15;
          let lines = wrapText(d.data.name, maxCharsPerLine);

          // Si encore trop de lignes, augmenter la largeur plut√¥t que limiter les lignes
          while (lines.length > 4 && maxCharsPerLine < 30) {
            maxCharsPerLine += 2;
            lines = wrapText(d.data.name, maxCharsPerLine);
          }

          // Trouver la ligne la plus longue pour la largeur
          const maxLineLength = Math.max(...lines.map((line) => line.length));

          return {
            width: maxLineLength * charWidth + padding * 2,
            height: Math.min(lines.length, 5) * lineHeight + padding * 2,
          };
        }

        return {
          radius: getNodeRadius(d),
        };
      }

      function wrapText(text, maxCharsPerLine) {
        const lines = [];
        let currentLine = "";
        const words = text.split(" ");

        for (let word of words) {
          if ((currentLine + word).length > maxCharsPerLine) {
            if (currentLine) lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = currentLine ? currentLine + " " + word : word;
          }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
      }

      // =======================
      // Rendu principal
      // =======================
      function update() {
        g.selectAll("*").remove();

        const root = d3.hierarchy(data);
        const radius = Math.min(width, height) / 2 - 80;

        d3.tree().size([2 * Math.PI, radius])(root);

        // -------- Liens --------
        g.selectAll("path")
          .data(root.links())
          .enter()
          .append("path")
          .attr("d", (d) => {
            const source =
              d.source.data.x_manual !== undefined
                ? { x: d.source.data.x_manual, y: d.source.data.y_manual }
                : polarToCartesian(d.source.x, d.source.y);

            const target =
              d.target.data.x_manual !== undefined
                ? { x: d.target.data.x_manual, y: d.target.data.y_manual }
                : polarToCartesian(d.target.x, d.target.y);

            return `M${source.x},${source.y} L${target.x},${target.y}`;
          });

        // -------- N≈ìuds --------
        const node = g
          .selectAll("g.node")
          .data(root.descendants())
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => {
            if (d.data.x_manual !== undefined) {
              return `translate(${d.data.x_manual}, ${d.data.y_manual})`;
            }
            return `rotate(${(d.x * 180) / Math.PI - 90}) translate(${d.y},0)`;
          })
          .call(drag);

        // Ajouter des cercles pour les n≈ìuds courts
        node
          .filter((d) => !shouldUseRectangle(d))
          .append("circle")
          .attr("r", (d) => getNodeRadius(d))
          .style("fill", (d) => d.data.color || "#b3e5ff")
          .classed("selected", (d) => isSelectedNode(d))
          .on("click", (event, d) => {
            event.stopPropagation();
            selectedNodeData = d.data;
            update();
          });

        // Ajouter des rectangles pour les n≈ìuds longs
        node
          .filter((d) => shouldUseRectangle(d))
          .append("rect")
          .attr("x", (d) => -getNodeDimensions(d).width / 2)
          .attr("y", (d) => -getNodeDimensions(d).height / 2)
          .attr("width", (d) => getNodeDimensions(d).width)
          .attr("height", (d) => getNodeDimensions(d).height)
          .style("fill", (d) => d.data.color || "#b3e5ff")
          .classed("selected", (d) => isSelectedNode(d))
          .on("click", (event, d) => {
            event.stopPropagation();
            selectedNodeData = d.data;
            update();
          });

        node
          .append("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("transform", (d) => {
            if (d.data.x_manual !== undefined) return null;
            return `rotate(${-((d.x * 180) / Math.PI - 90)})`;
          })
          .style("pointer-events", "none")
          .style("font-size", "13px")
          .each(function (d) {
            const maxCharsPerLine = shouldUseRectangle(d) ? 40 : 10;
            const lines = wrapText(d.data.name, maxCharsPerLine);
            const lineSpacing = 1.4;
            const startY = -(lines.length - 1) * lineSpacing * 0.5;

            d3.select(this)
              .selectAll("tspan")
              .data(lines)
              .enter()
              .append("tspan")
              .attr("x", 0)
              .attr("y", (d, i) => startY + i * lineSpacing + "em")
              .text((line) => line);
          });
      }

      // =======================
      // Actions UI
      // =======================
      function addChild() {
        if (!selectedNodeData) return alert("S√©lectionne un n≈ìud");

        const name = prompt("Nom du nouvel √©l√©ment ?");
        if (!name) return;

        selectedNodeData.children = selectedNodeData.children || [];
        const newChild = { name };

        // Initialiser la position du nouvel enfant √† c√¥t√© du parent (d√©calage de 100px)
        if (selectedNodeData.x_manual !== undefined) {
          newChild.x_manual = selectedNodeData.x_manual + 100;
          newChild.y_manual = selectedNodeData.y_manual + 50;
        }

        selectedNodeData.children.push(newChild);
        update();
      }

      function renameNode() {
        if (!selectedNodeData) return alert("S√©lectionne un n≈ìud");

        const name = prompt("Nouveau nom ?", selectedNodeData.name);
        if (!name) return;

        selectedNodeData.name = name;
        update();
      }

      function deleteNode() {
        if (!selectedNodeData)
          return alert("Impossible de supprimer la racine");

        // Trouver le parent pour acc√©der aux enfants
        function findParentAndDelete(node) {
          if (!node.children) return false;
          const index = node.children.indexOf(selectedNodeData);
          if (index !== -1) {
            node.children.splice(index, 1);
            return true;
          }
          for (let child of node.children) {
            if (findParentAndDelete(child)) return true;
          }
          return false;
        }

        if (data === selectedNodeData) {
          return alert("Impossible de supprimer la racine");
        }

        findParentAndDelete(data);
        selectedNodeData = null;
        update();
      }

      function renameMap() {
        const nomcartementale = prompt(
          "Nouveau nom de la carte mentale ?",
          data.nomcartementale,
        );
        if (!nomcartementale) return;

        data.nomcartementale = nomcartementale;
        update();
      }

      function changeColor() {
        if (!selectedNodeData) return alert("S√©lectionne un n≈ìud");

        const colorPicker = document.getElementById("colorPicker");
        colorPicker.value = selectedNodeData.color || "#b3e5ff";
        colorPicker.click();
      }

      document
        .getElementById("colorPicker")
        .addEventListener("change", function (e) {
          if (selectedNodeData) {
            selectedNodeData.color = e.target.value;
            update();
          }
        });

      function exportData() {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = data.nomcartementale.replace(/\s+/g, "-") + ".json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        alert("Carte mentale export√©e avec succ√®s!");
      }

      function importData() {
        const fileInput = document.getElementById("fileInput");
        fileInput.click();
      }

      document
        .getElementById("fileInput")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (event) {
            try {
              const importedData = JSON.parse(event.target.result);
              if (!importedData.name) {
                return alert(
                  "Fichier JSON invalide. Assurez-vous qu'il contient une propri√©t√© 'name'.",
                );
              }
              data = importedData;
              selectedNodeData = null;
              update();
              alert("Carte mentale import√©e avec succ√®s!");
            } catch (error) {
              alert("Erreur lors de la lecture du fichier: " + error.message);
            }
          };
          reader.readAsText(file);
          e.target.value = ""; // R√©initialiser l'input
        });

      // =======================
      // Raccourcis clavier
      // =======================
      document.addEventListener("keydown", function (event) {
        // V√©rifier que l'utilisateur n'est pas en train de taper dans un input
        if (
          event.target.tagName === "INPUT" ||
          event.target.tagName === "TEXTAREA"
        ) {
          return;
        }

        switch (event.key.toUpperCase()) {
          case "DELETE":
            event.preventDefault();
            deleteNode();
            break;
          case "ENTER":
            event.preventDefault();
            renameNode();
            break;
          case "A":
            event.preventDefault();
            addChild();
            break;
          case "R":
            event.preventDefault();
            renameMap();
            break;
          case "I":
            event.preventDefault();
            importData();
            break;
          case "F7":
            event.preventDefault();
            exportData();
            break;
        }
      });

      // =======================
      // Initialisation
      // =======================
      update();
    </script>
  </body>
</html>
